<!DOCTYPE html>
<HTML>
<HEAD>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<META http-equiv="content-language" content="en">
<META http-equiv="cache-control" content="no-cache">
<META http-equiv="expires" content="Thu, 01 Jan 1970 00:00:00 GMT">
<META http-equiv="pragma" content="no-cache">
<META http-equiv="content-style-type" content="text/css">
<LINK href="VideoNotation.css" rel="stylesheet" type="text/css">
<META http-equiv="content-script-type" content="text/javascript">
<SCRIPT src="VideoNotation.js"></SCRIPT>

<TITLE>A Video Notation, stride-match</TITLE>
</HEAD>
<BODY>

<B class="big">Stride-Match</B><BR>
Stride-match is the notation's engine.<BR>
<I>Nesting stride-match notations can create extremely complex processes that are nonetheless fairly easy to read.</I><BR>

<BR>
<A name="stride-match"></A>
<B class="underline super">Stride-Match</B>

<P>1, Strides are input streams cut into uniform spans that share a characteristic pattern of elements.</P>
<P>2, The stride's elements are paired to single character tokens on a 1-to-1 basis.</P>
<P>3, Elements are assigned to the matching tokens in <TT>((</TT><I>new</I><TT>(</TT><I>match</I><TT>)</TT><I>end</I><TT>)</TT><I>miss</I><TT>)</TT> and the notations in them are run.</P>
<P>4, This process loops for all input strides until the input stream is exhausted.</P>
<P>5, Any leftover 'stale' elements are force-passed unchanged.</P>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>

<TR><TD colspan=2><TT class="nowrap">(<TT class="white"><I>stride</I></TT>)((<TT class="white"><I>new</I></TT>(<TT class="white"><I>match</I></TT>)<TT class="white"><I>end</I></TT>)<TT class="white"><I>miss</I></TT>)</TT>&nbsp;</TD>
    <TD>This is a fully populated stride-match using labels in place of actual notations.</TD></TR>
<TR><TD><BR></TD></TR>

<TR><TD><TT class="nowrap">(<TT class="white"><I>stride</I></TT>)</TT></TD>
    <TD class="center"><TT class="nowrap">(<TT class="white"><I>match</I></TT>)</TT></TD>
    <TD>Input elements are buffered until stride number of elements have been accumulated.
        <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
        <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>If the buffer's content matches the pattern found in <I>stride</I>, the buffer is passed to the <I>match</I> notation, the input pointer is increased by the length of <I>stride</I>, and processing loops back to scan for more input.</TD></TR>
        <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>If not matched, <I>match</I> is skipped and a minimum number of elements: 1 for pictures or 2 for scans & halfpics, are passed to follow-on notation and the scanner pointer is incremented by 1 or 2 before looping back.</TD></TR>
        </TABLE>
        The <I>match</I> notation can contain any valid notation including embedded stride-matches.</TD></TR>
<TR><TD><BR></TD></TR>

<TR><TD><TT class="nowrap">(<TT class="white"><I>stride</I></TT>)</TT><BR><TT class="nowrap">(<TT class="white"><I>stride</I></TT>)</TT><BR><TT class="nowrap">(<TT class="white"><I>stride</I></TT>)</TT></TD>
    <TD class="center"><TT class="nowrap">(<TT class="white"><I>new</I></TT>(<TT class="white"><I>match</I></TT>))</TT><BR><TT class="nowrap">((<TT class="white"><I>match</I></TT>)<TT class="white"><I>end</I></TT>)</TT><BR><TT class="nowrap">(<TT class="white"><I>new</I></TT>(<TT class="white"><I>match</I></TT>)<TT class="white"><I>end</I></TT>)</TT></TD>
    <TD>If the first match of a new stream, the input stride is passed to the <I>new</I> notation (e.g., for scene change). Thereafter, matching strides are passed to the <I>match</I> notation. If an end match, the input stride is passed to the <I>end</I> notation. The <I>new</I> & <I>end</I> notations can contain any valid notations including embedded stride-matches.</TD></TR>
<TR><TD><BR></TD></TR>

<TR><TD><TT class="nowrap">(<TT class="white"><I>stride</I></TT>)</TT><BR><TT class="nowrap">(<TT class="white"><I>stride</I></TT>)</TT><BR><TT class="nowrap">(<TT class="white"><I>stride</I></TT>)</TT></TD>
    <TD class="center"><TT class="nowrap">(((<TT class="white"><I>match</I></TT>))<TT class="white"><I>miss</I></TT>)</TT><BR><TT class="nowrap">((<TT class="white"><I>new</I></TT>(<TT class="white"><I>match</I></TT>))<TT class="white"><I>miss</I></TT>)</TT><BR><TT class="nowrap">(((<TT class="white"><I>match</I></TT>)<TT class="white"><I>end</I></TT>)<TT class="white"><I>miss</I></TT>)</TT></TD>
    <TD>If not matched, a minimum number of elements: 1 for pictures or 2 for scans & halfpics, are passed to the <I>miss</I> notation. The <I>miss</I> notation can contain any valid notation including embedded stride-matches.</TD></TR>
</TABLE>

<BR>
<B>Details:</B>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR><TD class="nowrap center"><B><I>stride</I></B>&nbsp;</TD><TD>Each stride-match builds a purpose-built scanner that accumulates input elements as they are received and monitors the accumulation looking for patterns. For example, strides for reverse 2-3-2-3 pull-down are <TT>(Aa<B class="red">B</B>b<B class="red">B</B>cC<B class="red">d</B>D<B class="red">d</B>)</TT>.
The scanner consequentially looks in the accumulator for 10 halfpics that have a "..<B class="red">1</B>.<B class="red">1</B>..<B class="red">2</B>.<B class="red">2</B>" pattern.
  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
  <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>If <I>stride</I> <B class="red">does not find</B> a "..1.1..2.2" pattern, it
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>signals pattern="" &</TD></TR>
    <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>passes only the first 2 halfpics &</TD></TR>
    <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>increments the scanner by 2 &</TD></TR>
    <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>resumes accumulating (i.e., it loops).</TD></TR>
    </TABLE></TD></TR>
  <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>If <I>stride</I> <B class="red">does find</B> a "..1.1..2.2" pattern, it
    <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
    <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>signals pattern="AaBbBcCdDd" &</TD></TR>
    <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>passes all 10 halfpics &</TD></TR>
    <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>increments the scanner by 10 &</TD></TR>
    <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>resumes accumulating (i.e., it loops).</TD></TR>
    </TABLE></TD></TR>
  <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>If the input stream ends short of a full stride, <TT>((</TT><I>new</I><TT>(</TT><I>match</I><TT>)</TT><I>end</I><TT>)</TT><I>miss</I><TT>)</TT> is entirely skipped & the 'stale' halfpics are force-passed unchanged to follow-on notation.</TD></TR>
  </TABLE></TD></TR>
<TR><TD class="nowrap center"><B><I>new</I></B>&nbsp;</TD><TD>is optional. It operates identically as <I>match</I> but only on the first matching stride of a new stream (thereby handling scene changes for example).</TD></TR>
<TR><TD class="nowrap center"><B><I>match</I></B>&nbsp;</TD><TD>is required.
  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
  <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>If pattern="", then <I>match</I> merely passes along whatever <I>stride</I> passed to it.</TD></TR>
  <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>If&nbsp;pattern="<B>A</B><B class="red">a</B><B>B</B><B class="red">b</B>B<B class="red">c</B><B>C</B><B class="red">d</B><B>D</B>d"&nbsp;for&nbsp;example,&nbsp;then&nbsp;<I>match</I>&nbsp;uses<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>A</B><B class="red">a</B><B>B</B><B class="red">b</B>&nbsp;<B class="red">c</B><B>C</B><B class="red">d</B><B>D</B>&nbsp;&nbsp;&nbsp;to assign elements to tokens as follows:
    <PRE class="white">
&bullet; Halfpic <B>1</B> is assigned to <B>A</B>                  &bullet; Halfpic <B class="red">6</B> is assigned to <B class="red">c</B>
&bullet;         <B class="red">2</B>             to <B class="red">a</B>                  &bullet;         <B>7</B>             to <B>C</B>
&bullet;         <B>3</B>             to <B>B</B>                  &bullet;         <B class="red">8</B>             to <B class="red">d</B>
&bullet;         <B class="red">4</B>             to <B class="red">b</B>                  &bullet;         <B>9</B>             to <B>D</B>
&bullet;         <B>5</B> is ignored (<B>B</B> already assigned) &nbsp; &bullet;        <B>10</B> is ignored (<B class="red">d</B> already assigned)</PRE>
  </TABLE>With this scheme, elements can be rearranged and/or dropped and/or repeated without limit.</TD></TR>
<TR><TD class="nowrap center"><B><I>end</I></B>&nbsp;</TD><TD>is optional. It operates identically as <I>new</I> but on the ending matching stride of course.</TD></TR>
<TR><TD class="nowrap center"><B><I>miss</I></B>&nbsp;</TD><TD>is optional. It accumulates input elements passed to it while the <I>stride</I> continues to not be matched and it uses that input in whatever notation it contains. <I>miss</I> has the following important properties:
  <TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
  <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>If there's a stream break during the accumulation: if the stride-match switches from <I>miss</I> to <I>match</I> or from <I>match</I> to <I>miss</I>, then the stride-match signals the discontinuity by tagging the new elements as a new stream. When <I>match</I> signals the discontinuity, <I>miss</I> responds by force-passing the current accumulated input elements, if any, and by accumulating anew.</TD></TR>
  <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>When <I>stride</I> exhausts its input stream and consequently has nothing to pass, <I>miss</I> is automatically skipped. So, when it's invoked, <I>miss</I> will always receive at least one element and need not defend against (or otherwise consider) null input.</TD></TR>
  <TR><TD>&nbsp;&bullet;&nbsp;</TD><TD>Any 'stale' elements left in <I>miss</I> when the input stream is exhausted are force-passed unchanged.</TD></TR>
  </TABLE></TD></TR>
</TABLE>

<BR>
Examples of stride-match for simple block filtering.
<PRE class="white">
<TT>(1)(1)</TT> // a 1-to-1 stride-match passes all streams &mdash; a do-nothing stride-match
<TT class="nowrap">(1)()</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a 1-to-nothing stride-match discards all streams
<TT class="nowrap">(<TT class="white"><I>stride</I></TT>)((1)())</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// discards all matching strides &mdash; <I>match</I> does the discarding
<TT class="nowrap">(<TT class="white"><I>stride</I></TT>)(((<TT class="white"><I>match</I></TT>))(1)())</TT> // discards all non-matching strides &mdash; <I>miss</I> does the discarding
<TT class="nowrap">(<TT class="white"><I>stride</I></TT>)((1)()(<TT class="white"><I>match</I></TT>))</TT>&nbsp; // discards only a matching stream's beginning stride &mdash; <I>new</I> does the discarding
<TT class="nowrap">(<TT class="white"><I>stride</I></TT>)((<TT class="white"><I>match</I></TT>)(1)())</TT> // discards only a matching stream's ending stride &mdash; <I>end</I> does the discarding
</PRE>

<BR>
<B class="underline">Scan Blend</B>
<PRE class="white">
<TT class="nowrap">&="blend"</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">+-new stride------->+-more strides----->&nbsp;&nbsp;+-end stride-------></TT>
<TT class="nowrap">sfps.fromfile("source")</TT>&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">[A+b_______________][C+d_______________]..[Y+z_______________]</TT>
<TT class="nowrap">[sps(ab)</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">(A_______)(b_______)(C_______)(d_______)..(Y_______)(z_______)</TT>
    <TT class="nowrap">(a&ba&b)</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">(A&b_____)(A&b_____)(C&d_____)(C&d_____)..(Y&z_____)(Y&z_____)</TT> blend
<TT class="nowrap">pps]pfps.tofile("target")</TT>&nbsp;// <TT class="purple nowrap">[A&bA&b____________][C&dC&d____________]..[Y&zY&z____________]</TT> weave, encode</PRE>
&bullet;&nbsp;PTSs:&nbsp;Unforced
&bullet;&nbsp;Combing:&nbsp;None
&bullet;&nbsp;Judder:&nbsp;None
&bullet;&nbsp;Cadence:&nbsp;None
&bullet;&nbsp;Burden:&nbsp;1&nbsp;halfpic&nbsp;blend&nbsp;per&nbsp;1/(sps)&nbsp;seconds
&bullet;&nbsp;Generations:&nbsp;0<BR>

<BR>
<PRE class="white">
<TT class="white"><B class="underline super" style="margin-left:-0.6em">Bob Decomb</B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>// <TT class="purple nowrap">+-new stride------->+-more strides----->&nbsp;&nbsp;+-end stride-------></TT>
<TT class="nowrap">sfps.fromfile("source")</TT>&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">[A+b_______________][C+d_______________]..[Y+z_______________]</TT>
<TT class="nowrap">[sps(ab)</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">(A_______)(b_______)(C_______)(d_______)..(Y_______)(z_______)</TT>
    <TT class="nowrap">(aabb)</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">(A__)(A__)(b__)(b__)(C__)(C__)(d__)(d__)..(Y__)(Y__)(z__)(z__)</TT> double every scan
<TT class="nowrap">pps]pfps.tofile("target")</TT>&nbsp;// <TT class="purple nowrap">[AA______][bb______][CC______][dd______]..[YY______][zz______]</TT> weave, encode</PRE>
&bullet;&nbsp;PTSs:&nbsp;Unforced
&bullet;&nbsp;Combing:&nbsp;None
&bullet;&nbsp;Judder:&nbsp;None
&bullet;&nbsp;Cadence:&nbsp;None
&bullet;&nbsp;Burden:&nbsp;None
&bullet;&nbsp;Generations:&nbsp;0
&bullet;&nbsp;One&nbsp;line&nbsp;up-down&nbsp;'bob'&nbsp;cycle&nbsp;at&nbsp;1/(sps)&nbsp;rate<BR>

<BR>
<B class="underline">Bob Decomb With Blend</B>
<PRE class="white">
<TT class="nowrap">&="blend"</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">+-new stride------->+-more strides----->&nbsp;&nbsp;+-end stride-------></TT>
<TT class="nowrap">sfps.fromfile("source")</TT>&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">[A+b_______________][C+d_______________]..[Y+z_______________]</TT>
<TT class="nowrap">[sps(ab)</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">(A_______)(b_______)(C_______)(d_______)..(Y_______)(z_______)</TT>
    <TT class="nowrap">(aa&ba&bb)</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">(A__)(A&b)(A&b)(b__)(C__)(C&d)(C&d)(d__)..(Y__)(Y&z)(Y&z)(z__)</TT> blend
<TT class="nowrap">pps]pfps.tofile("target")</TT>&nbsp;// <TT class="purple nowrap">[AA&b____][A&bb____][CC&d____][C&dd____]..[YY&z____][Y&zz____]</TT> weave, encode</PRE>
&bullet;&nbsp;PTSs:&nbsp;Unforced
&bullet;&nbsp;Combing:&nbsp;None
&bullet;&nbsp;Judder:&nbsp;None
&bullet;&nbsp;Cadence:&nbsp;None
&bullet;&nbsp;Burden:&nbsp;1&nbsp;halfpic&nbsp;blend&nbsp;per&nbsp;1/(sps)&nbsp;seconds
&bullet;&nbsp;Generations:&nbsp;0<BR>

<BR>
<B class="underline">SNM Decomb</B>
<PRE class="white">
<TT class="nowrap">&="interpolate"</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">+-new stride------->+-more strides----->&nbsp;&nbsp;+-end stride-------></TT>
<TT class="nowrap">sfps.fromfile("source")</TT>&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">[A+b_______________][C+d_______________]..[Y+z_______________]</TT>
<TT class="nowrap">[sps(ab)</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">(A_______)(b_______)(C_______)(d_______)..(Y_______)(z_______)</TT>
    <TT class="nowrap">(aa&b</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <TT class="purple nowrap">(A_______)(a&b_____)</TT>                                           new match: half-bob
    <TT class="nowrap">(a^&b))</TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT class="purple nowrap">(C_______)(b&d_____)..(Y_______)(x&z_____)</TT> match: interp
<TT class="nowrap">pps]pfps.tofile("target")</TT>&nbsp;// <TT class="purple nowrap">[AA&b______________][Cc________________]..[Yy________________]</TT> weave, encode</PRE>
&bullet;&nbsp;PTSs:&nbsp;Unforced
&bullet;&nbsp;Combing:&nbsp;None
&bullet;&nbsp;Judder:&nbsp;None
&bullet;&nbsp;Cadence:&nbsp;None
&bullet;&nbsp;Burden:&nbsp;1&nbsp;halfpic&nbsp;interpolation&nbsp;per&nbsp;1/(sps)&nbsp;seconds
&bullet;&nbsp;Generations:&nbsp;0+1<BR>

<BR>
<B class="underline">SME Decomb</B>
<PRE class="white">
<TT class="nowrap">&="interpolate"</TT>           // <TT class="purple nowrap">+-new stride------->+-more strides----->&nbsp;&nbsp;+-end stride-------></TT>
<TT class="nowrap">sfps.fromfile("source")</TT>   // <TT class="purple nowrap">[A+b_______________][C+d_______________]..[Y+z_______________]</TT>
<TT class="nowrap">[sps(ab)</TT>                  // <TT class="purple nowrap">(A_______)(b_______)(C_______)(d_______)..(Y_______)(z_______)</TT>
    <TT class="nowrap">((a&$b)</TT>               // <TT class="purple nowrap">(A&c_____)(b_______)(C&e_____)(d_______)..</TT>                     match: interp
      <TT class="nowrap">a&bb)</TT>               //                                         <TT class="purple nowrap">..(Y&z_____)(z_______)</TT> end match: half-bob
<TT class="nowrap">pps]pfps.tofile("target")</TT> // <TT class="purple nowrap">[Bb________________][Dd________________]..[Y&zz______________]</TT> weave, encode</PRE>
&bullet;&nbsp;PTSs:&nbsp;Unforced
&bullet;&nbsp;Combing:&nbsp;None
&bullet;&nbsp;Judder:&nbsp;None
&bullet;&nbsp;Cadence:&nbsp;None
&bullet;&nbsp;Burden:&nbsp;1&nbsp;halfpic&nbsp;interpolation&nbsp;per&nbsp;1/(sps)&nbsp;seconds
&bullet;&nbsp;Generations:&nbsp;1+0<BR>

<BR>
<B class="underline super">SNME Decomb</B>
<PRE class="white">
<TT class="nowrap">&="interpolate"</TT>           // <TT class="purple nowrap">+-new stride------->+-more strides----->&nbsp;&nbsp;+-end stride-------></TT>
<TT class="nowrap">sfps.fromfile("source")</TT>   // <TT class="purple nowrap">[A+b_______________][C+d_______________]..[Y+z_______________]</TT>
<TT class="nowrap">[sps(ab)</TT>                  // <TT class="purple nowrap">(A_______)(b_______)(C_______)(d_______)..(Y_______)(z_______)</TT>
    <TT class="nowrap">(a a&b a&$ b</TT>          // <TT class="purple nowrap">(A__)(A&b)(A&C)(b__)</TT>                                           new match: half-bob - interp
    <TT class="nowrap">(a ^&b a&$ b)</TT>         //                     <TT class="purple nowrap">(C__)(b&d)(C&E)(d__)..</TT>                     match: interp - interp
     <TT class="nowrap">a ^&b a&b b)</TT>         //                                         <TT class="purple nowrap">..(Y__)(x&z)(Y&z)(z__)</TT> end match: interp - half-bob
<TT class="nowrap">pps]pfps.tofile("target")</TT> // <TT class="purple nowrap">[AA&b____][Bb______][Cc______][Dd______]..[Yy______][Y&zz____]</TT> weave, encode</PRE>
&bullet;&nbsp;PTSs:&nbsp;Unforced
&bullet;&nbsp;Combing:&nbsp;None
&bullet;&nbsp;Judder:&nbsp;None
&bullet;&nbsp;Cadence:&nbsp;None
&bullet;&nbsp;Burden:&nbsp;2&nbsp;halfpic&nbsp;interpolations&nbsp;per&nbsp;1/(sps)&nbsp;seconds
&bullet;&nbsp;Generations:&nbsp;0+1+1+0<BR>

<BR>
</BODY></HTML>
