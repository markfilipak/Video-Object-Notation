<!DOCTYPE html>
<HTML>
<HEAD>
<META http-equiv="content-type" content="text/html; charset=utf-8">
<META http-equiv="content-language" content="en">
<META http-equiv="cache-control" content="no-cache">
<META http-equiv="expires" content="Thu, 01 Jan 1970 00:00:00 GMT">
<META http-equiv="pragma" content="no-cache">
<META http-equiv="content-style-type" content="text/css">
<LINK href="VideoNotation.css" rel="stylesheet" type="text/css">
<META http-equiv="content-script-type" content="text/javascript">
<SCRIPT src="VideoNotation.js"></SCRIPT>

<TITLE>A Video Notation, Properties & Methods</TITLE>
</HEAD>
<BODY>

A successful method performs the specified method and returns the stream.<BR>
An unsuccessful method does nothing and returns an error.<BR>
Successfully setting a property sets the property and returns the stream.<BR>
Unsuccessfully setting a property does nothing and returns an error.<BR>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0>
<TR><TD></TD><TD>&nbsp;&nbsp;</TD><TD></TD></TR>
<TR><TD class="nowrap underline center"><B>System Frame Objects</B> [see note 1]</TD><TD></TD><TD class="nowrap underline center"><B>System Image Objects</B></TD></TR>
<TR><TD>
<!-- System Frame Objects -->
<P><I>stream</I><B class="wheat">.fifo</B> is the buffer</P>
<P><I>stream</I><B class="wheat">.newest</B> is the most recent element</P>
<P><B class="wheat">[</B><I>token</I><B class="wheat">]</B> is this element within a stride</P>
<P><I>fps</I> focuses on the element stream</P>
<P><I>fps</I><B class="wheat">.a</B> focuses on all audio streams</P>
<P><B class="wheat">$.</B>a<I>n</I> (<I>n</I> = 0 1 2...) focuses on audio stream <I>n</I></P>
<P><I>fps</I><B class="wheat">.s</B> focuses on all subtitle streams</P>
<P><B class="wheat">$.</B>s<I>n</I> (<I>n</I> = 0 1 2...) focuses on subtitle stream <I>n</I></P>
</TD><TD><BR></TD><TD>
<!-- System Image Objects -->
<P><I>fifo</I> is the image buffer</P>
<P><I>ips</I> (<I>ips</I> = hps pps sps tps) focuses on an image stream</P>
<P><I>newest</I> is most recent image</P>
<P><I>token</I> is this image within a stride</P>
</TD></TR>
<TR><TD><BR></TD></TR>
<TR><TD class="nowrap underline center"><B>System Properties</B> [see note 2]</TD><TD></TD><TD class="nowrap underline center"><B>System Methods</B> [see note 3]</TD></TR>
<TR><TD>

<!-- System Properties -->
<P>$<I>v</I> (r/w, <I>v</I> = 0..9 A..Z a..z) general purpose variables</P>
<P>$<I>v</I>.Bcount (r) gets number of bytes in $<I>v</I></P>
<P>$<I>v</I>.floor (r) gets integer value of $<I>v</I></P>
<P><I>[fifo].n</I> (r) gets number of [fifo] elements</P>
<P><I>fps</I> (r) gets element stream</P>
<P><B class="wheat">$.</B>a.</I> (r) gets number of audio streams</P>
<P><B class="wheat">$.</B><I>decoderName</I> (r) gets <B>!</B> if decoder does not exist</P>
<P><B class="wheat">$.</B><I>decoderName</I> (w) overrides intrinsic decoder</P>
<P><B class="wheat">$.</B>n</I> (r) gets most recent element number</P>
<P><B class="wheat">$.</B>pcr</I> (r) gets program clock reference [see note 4]</P>
<P><B class="wheat">$.</B>pixform</I> (r/w) gets/sets pixel format (e.g., yuv420p)</P>
<P><B class="wheat">$.</B>pixform.<I>pixForm</I> (r) gets <B>!</B> if <I>pixForm</I> is not supported</P>
<P><B class="wheat">$.</B>dpi (r) gets number of dots per line</P>
<P><B class="wheat">$.</B><I>encoderName</I> (r) gets <B>!</B> if encoder does not exist</P>
<P><B class="wheat">$.</B><I>encoderName</I> (w) overrides intrinsic encoder</P>
<P><B class="wheat">$.</B>fifo (r) gets number of ips.fifo images
<P><B class="wheat">$.</B>lpi (r) gets number of lines per image</P>
<P><B class="wheat">$.</B>n (r) gets most recent image number</P>
<P><B class="wheat">$.</B>ppr (r) gets number of pixels per row</P>
<P><B class="wheat">$.</B>rps (r) gets number of rows per sample</P>

</TD><TD></TD><TD>

<!-- System Methods -->
<P><B class="wheat">$.</B><I>decoderName</I><B class="wheat">("</B><I>parameters</I><B class="wheat">")</B> decodes fps stream, outputs ips stream</P>
<P><B class="wheat">$.fifo.drop</B> discards $'s oldest element</P>
<P><B class="wheat">$.fifo.dropall</B> discards all fps.fifo elements</P>
<P><B class="wheat">$.fifo.pop</B> moves $'s oldest element to $</P>
<P><B class="wheat">$.fifo.popall</B> moves all fps.fifo elements to fps</P>
<P><B class="wheat">$.fromfile("</B><I>filespec</I><B class="wheat">")</B> reads fps stream from a file</P>
<P><B class="wheat">$.fromport("</B><I>domain</I><B class="wheat">","</B><I>port</I><B class="wheat">")</B> reads fps stream from <I>domain</I>:<I>port</I></P>
<P><B class="wheat">$.fromport("</B><I>port</I><B class="wheat">")</B> reads fps stream from localhost:<I>port</I></P>
<P><B class="wheat">$.tofile("</B><I>filespec</I><B class="wheat">")</B> writes fps stream to a file</P>
<P><B class="wheat">$.toport("</B><I>domain</I><B class="wheat">","</B><I>port</I><B class="wheat">")</B> writes fps stream to <I>domain</I>:<I>port</I></P>
<P><B class="wheat">$.toport("</B><I>port</I><B class="wheat">")</B> writes fps stream to localhost:<I>port</I></P>
<P><B class="wheat">$.usingport("</B><I>port</I><B class="wheat">")</B> connects via localhost:<I>port</I></P>
<P><B class="wheat">$.</B><I>encoderName</I><B class="wheat">("</B><I>parameters</I><B class="wheat">")</B> encodes ips, outputs fps</P>

</TD></TR>
<TR><TD><BR></TD></TR>
<TR><TD class="nowrap underline center"><B>Frame Properties</B></TD><TD></TD><TD class="nowrap underline center"><B>Frame Methods</B></TD></TR>
<TR><TD>

<!-- Frame Properties -->
<P><B class="wheat">.b</B> (r) gets <B>!</B> if not a B-frame</P>
<P><B class="wheat">.i</B> (r) gets <B>!</B> if not an I-frame</P>
<P><B class="wheat">.i.dts</B> (r/w) gets/sets I-frame's DTS</P>
<P><B class="wheat">.i.pts</B> (r/w) gets/sets I-frame's PTS</P>
<P><B class="wheat">.p</B> (r) gets <B>!</B> if not a P-frame</P>

</TD><TD></TD><TD>

<!-- Frame Methods -->
<P>Decoder Object:</P>
<P><B class="wheat">.<I>decoder_name</I></B> (w) change decoder, use defaults</P>
<P><B class="wheat">.<I>decoder_name</I>("<I>settings</I>")</B> (w) change decoder</P>
<P>Encoder Object:</P>
<P><B class="wheat">.<I>encoder_name</I></B> (w) change encoder, use defauts</P>
<P><B class="wheat">.<I>encoder_name</I>("<I>settings</I>")</B> (w) change encoder</P>
<P><B class="wheat">.fromfile("<I>filespec</I>")</B> (r)</P>
<P>[<I>token</I>].push copies this element to fps.fifo</P>
<P><B class="wheat">.tofile("<I>filespec</I>")</B></P>

<TR><TD><BR></TD></TR>
<TR><TD class="nowrap underline center"><B>Picture (or Scan) Properties</B></TD><TD></TD><TD class="nowrap underline center"><B>Picture (or Scan) Methods</B></TD></TR>
<TR><TD>

<!-- Picture (or Scan) Properties -->
<P><B class="wheat">.bpp</B> (r) gets bits per pixel</P>
<P><B class="wheat">.bpp</B> (r) gets image's bits per pixel</P>
<P><B class="wheat">.colormatrix</B> (r) gets encoder's colormatrix's name</P>
<P><B class="wheat">.encoder</B> (r) gets this encoder's name</P>
<P><B class="wheat">.ppr</B> (r) gets pixels per row</P>
<P><B class="wheat">.protocol</B> (r) gets encoder's protocol's name</P>
<P><B class="wheat">.ps</B> (r) gets pictures (or scans) per sec</P>
<P><B class="wheat">.ps</B> (w) forces ps, no conversion</P>
<P><B class="wheat">.rpp</B> (r) gets rows per picture</P>

</TD><TD></TD><TD>

<!-- Picture (or Scan) Methods -->
<P>Picture/Scan Methods:</P>
<P><B class="wheat">.bpp</B> (w) converts to new bpp</P>
<P><B class="wheat">.<I>colormatrix_name</I></B> (w) sets encoder's colormatrix</P>
<P><B class="wheat">.cropoff("<I>offleft</I>""<I>offtop</I>""<I>offright</I>""<I>offbottom</I>")</B> (w)</P>
<P><B class="wheat">.cropto("<I>w</I>""<I>h</I>")</B> (w) centered</P>
<P><B class="wheat">.cropto_spx("<I>pps/rpr</I>")</B> (w) new samples-to-pixel proportions, centered</P>
<P><B class="wheat">.fromfile("<I>filespec</I>")</B> (w)</P>
<P><B class="wheat">.matte("<I>left</I>""<I>top</I>""<I>right</I>""<I>bottom</I>")</B> (w)</P>
<P><B class="wheat">.matte_rgb("<I>r</I>""<I>g</I>""<I>b</I>")</B> (w)</P>
<P><B class="wheat">.matte_spx("<I>pps/rpr</I>")</B> (w) new samples-to-pixel proportions, centered</P>
<P><B class="wheat">.ppx("<I>ppr/rpp</I>")</B> (w) transform (rescale)</P>
<P><B class="wheat">.<I>protocol_name</I></B> (w) sets encoder's protocol</P>
<P><B class="wheat">.push</B> (w) copies this image to ips.fifo</P>
<P><B class="wheat">.tofile("<I>filespec</I>")</B> (w)</P>

<TR><TD><BR></TD></TR>
<TR><TD class="nowrap underline center"><B>Pixel Properties</B></TD><TD></TD><TD class="nowrap underline center"><B>Pixel Methods</B></TD></TR>
<TR><TD>

<!-- Pixel Properties -->
<P><B class="wheat">.r</B> (r/w) this pixel's red bits</P>
<P><B class="wheat">.g</B> (r/w) this pixel's green bits</P>
<P><B class="wheat">.b</B> (r/w) this pixel's blue bits</P>
<P><B class="wheat">.b="<I>n</I>"(?<I>iftrue</I>)</B> (r)</P>
<P><B class="wheat">.b="<I>n</I>"(:<I>iffalse</I>)</B> (r)</P>
<P><B class="wheat">.b="<I>n</I>"(?<I>iftrue</I>:<I>iffalse</I>)</B> (r)</P>

</TD><TD></TD><TD>

<!-- Pixel Methods -->
<P>Browsing:</P>
<P><B class="wheat">.left_pixel</B> (w)</P>
<P><B class="wheat">.next_pixel</B> (w) crosses rows but not pictures</P>
<P><B class="wheat">.top_row</B> (w)</P>
<P><B class="wheat">.next_row</B> (w) within picture</P>
<P><B class="wheat">.(<I>n</I>#$.next_row)</B> (w) within picture</P>
<P><B class="wheat">.(<I>n</I>#$.next_pixel)</B> (w) within picture</P>

<TR><TD><BR></TD></TR>

<TR><TD class="nowrap underline center"><B>Audio Properties</B></TD><TD></TD><TD class="nowrap underline center"><B>Audio Methods</B></TD></TR>
<TR><TD>

<!-- Audio Properties -->
Note: All of the <B>.a.</B> properties apply equally to <B>.a<I>n</I></B>

</TD><TD></TD><TD>

<!-- Audio Methods -->
Note: All of the <B>.a.</B> properties apply equally to <B>.a<I>n</I></B>
<P><B class="wheat">$.</B>a.fromfile("<I>filespec</I>") reads an audio stream from <I>filespec</I></P>
<P><B class="wheat">$.</B>a.upsample("<I>factor</I>") resamples audio by <I>factor</I> [see&nbsp;note&nbsp;5]</P>
<P><B class="wheat">$.</B>a.downsample("<I>factor</I>") resamples audio by 1/<I>factor</I> [see&nbsp;note&nbsp;5]</P>
<P><B class="wheat">$.</B>a.resample("<I>fromfps/tofps</I>") resamples audio by <I>fromfps/tofps</I> [see&nbsp;note&nbsp;5]</P>

</TD></TR></TABLE>

<BR>
<P>[note&nbsp;1] Backets, [], are parts of object labels, not delimiters.</P>

<P>[note&nbsp;2] The system automatically creates variables when encountered, variable declarations are not needed.</P>

<P>[note&nbsp;3] Replace  with the number of bytes in <I>filespec</I>, 1 byte per character for ANSI/UTF-8, 2 bytes per character for UTF-16.
No quotes or escape characters are needed.</P>

<P>[note&nbsp;4] PCR (program clock reference) is 90000tps (ticks-per-second) for VOB & M2TS, 1000tps for MKV; 60000tps & 30000tps have been seen for MP4.
"PCR" is called "tbn" (e.g., "90k tbn") by FFmpeg.</P>

<P>[note&nbsp;5] <I>factor</I> less than 1 down samples, which shrinks running time and pitches tonality sharp, while greater than 1 up samples.
More convenient forms are fps.a.resample("<I>toHz</I>/<I>fromHz</I>") & especially fps.a.resample("<I>from*ps</I>/<I>to*ps</I>").
For example, when mastering for <A href="VideoNotation.Commonly_Found.html#PAL-fast">PAL-fast^</A> (from 24pps to 25fps), audio resampling can be specified by <B class="wheat">fps.a.resample("0.96")</B> or <B class="wheat">fps.a.resample("46080/48000")</B> or <B class="wheat">fps.a.resample("24/25")</B>.
To reverse PAL-fast, <B class="wheat">fps.a.resample("1/0.96")</B> or <B class="wheat">fps.a.resample("48000/46080")</B> or <B class="wheat">fps.a.resample("25/24")</B>.</P>


<BR><BR>
<B>File concatenation.</B><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
$i='1' $s='/media/cdrom/VIDEO_TS/VTS_01_1.VOB'      ...craft the 1st source <I>filespec</I>
fps.fromfile($s.Bcount,$s)                          ...get the file
( [A] )                                             ...stride: single frames
( ( [A] )                                             ...match: output the frame
  [A]                                                 ...end match: output the frame
  $i++ $s='/media/cdrom/VIDEO_TS/VTS_01_'+$i+'.VOB'   ...& craft the next <I>filespec</I>
  fps.fromfile($s.Bcount,$s)                          ...& get the file
)
<I> ...continues with follow-on notation </I></PRE></TD></TR></TABLE>


<BR><BR>
<!-- Orphaned frames -->
<B>Orphaned frames at the beginning of a frame stream.</B>
Replace them with the 1st I-frame (when it's received).
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
$c='0'         ...copies of the first I-frame replace any preceding orphans
( [A] )        ...stride: single frames
(                ...match:
  ( [A].i!='!' )   ...query: is it an I-frame?
  ( ( $c+1 # [A] )   ...yes: copy of the newest image for each orphan + 1
    ..               ...& output the entire remaining stream
  )
  ( c++ )            ...no: the frame is an orphaned P- or B-frame, so count it
)
<I> ...continues with follow-on notation </I></PRE></TD></TR></TABLE>

<BR>
<B>Orphaned frames at the end of a frame stream, remuxing.</B>
Replace them with the newest I-frame.
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
fps.fifo.dropall      ...the newest I-frame replaces any succeeding orphans
( [A] )               ...stride: single frames
( (                     ...match but not end match:
    ( [A].i!='!' )        ...query-1: is [A] an I-frame?
    ( $i=[A] )__            ...yes-1: save the newest I-frame [see note 1]
    ( [A].b!='!' )        ...query-2: is [A] a B-frame?
    ( [A].push )            ...yes-2: copy [A] to the FIFO
    ( fps.fifo.dropall )    ...no-2: clear the FIFO
  )                     ...end match:
  ( [A].b!='!' )          ...query-3: is [A] a B-frame?
  ( ( fps.fifo+1 # $i )     ...yes-3: copy of the newest image for each orphan + 1
    fps.fifo.dropall        ...& clear the FIFO
  )
  ( fps.fifo.popall [A] )   ...no-3: output the frames in the FIFO & output [A]
)
<I> ...continues with follow-on notation </I></PRE></TD></TR></TABLE>

<BR>
<P>[note&nbsp;1] Following the 'yes-1' term, '__' is needed.
It prevents '([A].b!='!')' being interpreted as an 'no-1' term instead of 'query-2'.</P>

<BR>
<B>Orphaned frames at the end of a frame stream, recoding.</B>
Replace them with the newest image in the image stream.
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
fps.fifo.dropall        ...the newest image replaces any succeeding orphans
( [A] )                 ...stride: single frames
( (                       ...match but not end match:
    ( [A].b!='!' )          ...query-1: is [A] a B-frame?
    ( [A].push )              ...yes-1: copy [A] to the FIFO
    ( fps.fifo.dropall )      ...no-1: clear the FIFO
  )                       ...end match:
  ( [A].b!='!' )            ...query-2: is [A] a B-frame?
  ( ( fps.fifo+1 # newest )   ...yes-2: copy of the newest image for each orphan + 1
    fps.fifo.dropall          ...& clear the FIFO
  )
  ( fps.fifo.popall [A] )     ...no-2: output the frames in the FIFO & output [A]
)
<I> ...continues with follow-on notation </I></PRE></TD></TR></TABLE>

<BR>
<I>Professionals recommend that PTSs always begin at zero and are gap free.
Follow any of the above with PTS initialization, below, in order to supply valid presentation time stamps to the substituted frames.</I>


<BR><BR>
<!-- PTS initialization -->
<B>PTS initialization, remuxing</B> (works for constant or variable frame rate). The 1st frame must be an I-frame.
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
$p='0'                            ...(showing the computational details of the first 5 frames)
( [A] )                           ...stride: single frames
(                                   ...match:
  ( [A].i!='!' )                      ...query: is [A] an I-frame?
  ( [A].i.pts=$p.floor $f=[A].i.fps )   ...yes: set PTS & update $f based on this I-frame's fps (e.g., 24000/1001)
                                        ...1 $p =       0/1   | $p.floor =     0/1
                                        ...2    =  375375/100 |          =  3753/1
                                        ...3    =   75075/10  |          =  7507/1
                                        ...4    = 1126125/100 |          = 11261/1
                                        ...5    =   15015/1   |          = 15015/1
  [A] $p+=fps.pcr/$f                  ...output this frame & accumulate $p to have it ready for the next I-frame
)                                     ...  fps.pcr/$f = (90000/1)/(24000/1001) => 3753.75 => 375375/100
                                      ...1 $p =       0/1   + 375375/100                             =>  375375/100
                                      ...2    =  375375/100 + 375375/100 =>  750750/100              =>   75075/10
                                      ...3    =   75075/10  + 375375/100 =>  750750/100 + 375375/100 => 1126125/100
                                      ...4    = 1126125/100 + 375375/100 => 1501500/100              =>   15015/1
                                      ...5    =   15015/1   + 375375/100                             => 1876875/100
<I> ...continues with follow-on notation </I></PRE></TD></TR></TABLE>

<BR>
<B>PTS initialization, recoding</B> (works for constant or variable frame rate). The 1st image can be anything.
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD><PRE>
$p='0'
( A )               ...stride: single images
(                     ...match:
  A.pts=$p.floor        ...set PTS
  A $p+=fps.pcr/A.fps   ...& output the image & accumulate PTS
)
<I> ...continues with follow-on notation </I></PRE></TD></TR></TABLE>

<BR><BR></BODY></HTML>
